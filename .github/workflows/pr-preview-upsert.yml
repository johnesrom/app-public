# Este workflow gera imagem por PR e atualiza o repositório de manifests
# com um arquivo previews/pr-<numero>.yaml para o Argo CD sincronizar.
name: PR Preview Upsert

# Dispara quando PR é aberta, reaberta ou recebe novos commits.
on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - closed

# Permissões mínimas:
# - contents:read para clonar código
# - packages:write para publicar imagem no GHCR
permissions:
  contents: read
  packages: write

# Evita dois pipelines concorrentes para a mesma PR.
# Se chegar novo commit na PR, cancela a execução anterior.
concurrency:
  group: pr-preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  build-and-upsert:
    # Segurança: roda apenas para PRs do mesmo repositório (não forks).
    if: github.event.action != 'closed' && github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest

    steps:
      # Faz checkout do commit exato da PR (head SHA).
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      # Calcula coordenadas da imagem e expõe via outputs para próximos passos.
      - name: Define image metadata
        id: meta
        shell: bash
        run: |
          IMAGE_REPO="ghcr.io/johnesrom/app-public"
          IMAGE_TAG="pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.sha }}"
          APP_NAME="app-pr-${{ github.event.pull_request.number }}"
          NAMESPACE="preview-pr-${{ github.event.pull_request.number }}"
          HOST="pr-${{ github.event.pull_request.number }}.localtest.me"
          echo "image_repo=${IMAGE_REPO}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
          echo "pr_number=${{ github.event.pull_request.number }}" >> "$GITHUB_OUTPUT"
          echo "app_name=${APP_NAME}" >> "$GITHUB_OUTPUT"
          echo "namespace=${NAMESPACE}" >> "$GITHUB_OUTPUT"
          echo "host=${HOST}" >> "$GITHUB_OUTPUT"

      # Autentica no GitHub Container Registry.
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Builda a imagem com o Dockerfile do projeto e publica no GHCR.
      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.image_repo }}:${{ steps.meta.outputs.image_tag }}

      # Falha cedo com mensagem clara caso o token não esteja configurado.
      - name: Validate manifests token
        shell: bash
        env:
          MANIFESTS_REPO_TOKEN: ${{ secrets.MANIFESTS_REPO_TOKEN }}
        run: |
          if [ -z "${MANIFESTS_REPO_TOKEN}" ]; then
            echo "Secret ausente: MANIFESTS_REPO_TOKEN"
            echo "Configure em: app-public > Settings > Secrets and variables > Actions."
            exit 1
          fi

      # Clona o repositório GitOps onde ficam os manifests.
      # Requer secret MANIFESTS_REPO_TOKEN no repo app-public.
      - name: Checkout manifests repository
        uses: actions/checkout@v4
        with:
          repository: johnesrom/app-manifests
          token: ${{ secrets.MANIFESTS_REPO_TOKEN }}
          path: manifests

      # Cria/atualiza manifest completo por PR.
      # O Argo CD aplicará Namespace + Deployment + Service + Ingress.
      # Observação: usamos Deployment (não ReplicaSet direto), pois ele gerencia
      # ReplicaSet e Pod automaticamente.
      - name: Upsert PR preview manifests
        shell: bash
        run: |
          mkdir -p manifests/previews
          cat > "manifests/previews/pr-${{ steps.meta.outputs.pr_number }}.yaml" <<EOF
          apiVersion: v1
          kind: Namespace
          metadata:
            name: ${{ steps.meta.outputs.namespace }}
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ steps.meta.outputs.app_name }}
            namespace: ${{ steps.meta.outputs.namespace }}
            labels:
              app: ${{ steps.meta.outputs.app_name }}
              pr: "${{ steps.meta.outputs.pr_number }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: ${{ steps.meta.outputs.app_name }}
            template:
              metadata:
                labels:
                  app: ${{ steps.meta.outputs.app_name }}
                  pr: "${{ steps.meta.outputs.pr_number }}"
              spec:
                containers:
                  - name: app
                    image: ${{ steps.meta.outputs.image_repo }}:${{ steps.meta.outputs.image_tag }}
                    imagePullPolicy: Always
                    ports:
                      - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ steps.meta.outputs.app_name }}
            namespace: ${{ steps.meta.outputs.namespace }}
            labels:
              app: ${{ steps.meta.outputs.app_name }}
          spec:
            selector:
              app: ${{ steps.meta.outputs.app_name }}
            ports:
              - name: http
                port: 80
                targetPort: 80
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ steps.meta.outputs.app_name }}
            namespace: ${{ steps.meta.outputs.namespace }}
            labels:
              app: ${{ steps.meta.outputs.app_name }}
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /
          spec:
            ingressClassName: nginx
            rules:
              - host: ${{ steps.meta.outputs.host }}
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: ${{ steps.meta.outputs.app_name }}
                          port:
                            number: 80
          EOF

      # Versiona a mudança no app-manifests e envia para o GitHub.
      # Se o conteúdo não mudou, segue sem falhar.
      - name: Commit and push manifests
        shell: bash
        run: |
          cd manifests
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "previews/pr-${{ steps.meta.outputs.pr_number }}.yaml"
          git commit -m "preview(pr-${{ steps.meta.outputs.pr_number }}): ${{ steps.meta.outputs.image_tag }}" || echo "No changes to commit"
          git push
          
  delete-preview:
    if: github.event.action == 'closed'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout manifests repository
        uses: actions/checkout@v4
        with:
          repository: johnesrom/app-manifests
          token: ${{ secrets.MANIFESTS_REPO_TOKEN }}
          path: manifests

      - name: Remove PR preview manifest
        shell: bash
        run: |
          cd manifests
          FILE="previews/pr-${{ github.event.pull_request.number }}.yaml"
          if [ -f "$FILE" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git rm "$FILE"
            git commit -m "cleanup(pr-${{ github.event.pull_request.number }}): remove preview"
            git push
          else
            echo "Preview manifest not found."
          fi
